<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/synyx.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<img src="assets/synyx_rgb_farbe.svg">
				</section>
				<section>Trends in modern software architecture... and how to avoid them</section>
				<section>
					<section><h2>Hexagonal Architecture</h2></section>
					<section><h3>What is it?</h3>
						<p class="fragment">Typical, layered architectures typical provide abstractions "upward" from the domain model used in the database</p>
						<p class="fragment">Hexagonal architecture abstracts not only upward from the database, towards UI, Messaging System, etc as well</p>
						<img class="fragment" src="assets/Hexagonal.svg" width="450" height="300">
						<aside class="notes">
							Layered abstractions around the core domain model & business logic towards UI, DB, Messaging Systems etc.
						</aside>
					</section>
					<section><h3>Promise</h3>
						<p class="fragment">Protect your core domain model against leaking, thus making sure that changes in outer layers can never force you to change the core</p>
					</section>
					<section><h3>Pitfalls</h3>
						<p class="fragment">You end up with tons and tons of interfaces and duplications that constantly change during development, creating a unmaintainable mess</p>
					</section>
					<section><h3>Alternatives</h3>
						<p class="fragment">Apply abstractions where they make sense (eg, around your database entities)</p>
						<p class="fragment">Apply common sense everywhere else</p>
					</section>
					<section><h3>Conclusion</h3>
						<p class="fragment">Preventing your core domain model from leaking to the web is common sense</p>
						<p class="fragment">Preventing everything from leaking everywhere is ridiculous</p>
					</section>
				</section>
				<section>
					<section><h2>Reactive Stacks</h2></section>
					<section><h3>What is it?</h3>
						<p class="fragment">Non-blocking APIs typically invoke a callback function when their work is done</p>
					</section>
					<section><h3>Promise</h3>
						<p class="fragment">Because threads are no longer blocked waiting for downstream work to continue, we can build very responsive API</p>
					</section>
					<section><h3>Pitfalls</h3>
						<p class="fragment">The programming model is very different from classic, imperative code</p>
						<p class="fragment">The learning curve is very steep, it takes years (!) for a team of old-school java devs to fully embrace non-blocking APIs</p>
						<p class="fragment">Can be fully leveraged only when downstream APIs (database, external systems, ...) can also be used in a reactive way</p>
					</section>
					<section><h3>Alternatives</h3>
						<p class="fragment">Consider expected load scenarios before making design decisions</p>
						<p class="fragment">In most cases, horizontal scaling might prove to be more cost-efficient</p>
					</section>
					<section><h3>Conclusion</h3>
						<p class="fragment">From the Spring WebFlux documentation:</p>
						<p class="fragment">
							<q cite="https://docs.spring.io/spring-framework/reference/web/webflux/new-framework.html">
						    We expect that, for a wide range of applications, the shift is unnecessary.
						  	</q>
						</p>
					</section>
				</section>
				<section>
					<section><h2>CQRS</h2></section>
					<section><h3>What is it?</h3>
						<p class="fragment">Command-query responsibilty segregation essentials means separating the write- and the read-models of your application</p>
					</section>
					<section><h3>Promise</h3>
						<p class="fragment">Applications with an asymmetric read-write load (lots of writes, very little reads) and APIs (read operations require computed outputs, message/command-driven write APIs) benefit from seperate models</p>
					</section>
					<section><h3>Pitfalls</h3>
						<p class="fragment">Maintaining separate models, along with controller classes, business logic, persistence layers etc, leads to far more complex software projects</p>
						<p class="fragment">Separate models implcitly lead to eventual consistency (stale reads)</p>
					</section>
					<section><h3>Alternatives</h3>
						<p class="fragment">Always consider using a plain CRUD API first</p>
						<p class="fragment">When starting out with CRUD API, we can "evolve" a separate write API over time, keeping the CRUD API for read operations</p>
					</section>
					<section><h3>Conclusion</h3>
						<p class="fragment">From Greg Young's blog:</p>
						<blockquote class="fragment" cite="https://gregfyoung.wordpress.com/2012/03/02/cqrs/" style="text-align: left;">
					   	CQRS is not a silver bullet<br>
						CQRS is not a top level architecture<br>
						CQRS is not new<br>
						CQRS is not shiny<br>
						CQRS will not make your jump shot any better<br>
						[...]<br>
						CQRS can open many doors.
					  	</blockquote>
					</section>
				</section>
				<section>
					<section><h2>Event Sourcing</h2></section>
					<section><h3>What is it?</h3>
						<p class="fragment">Persistance pattern where the state of an aggregate (business object) is maintained as a stream of business events manipulating said aggregate</p>
					</section>
					<section><h3>Promise</h3>
						<p class="fragment">Focus on change instead of state leads to reactive, responsive systems</p>
						<p class="fragment">All domain objects implicitly have a history</p>
					</section>
					<section><h3>Pitfalls</h3>
						<p class="fragment">Very complex persistence pattern</p>
						<p class="fragment">Usually implemented along with CQRS, leading to expotentially more complex software systems</p>
						<p class="fragment">When used with CQRS, we aren't allowed to query the aggregates! Instead, we have to provide separate read models called projections</p>
					</section>
					<section><h3>Alternatives</h3>
						<p class="fragment">Event-driven systems can easily be build using CRUD APIs</p>
						<p class="fragment">When a history of domain objects is required (eg, for auditing), consider using envers</p>
					</section>
					<section><h3>Conclusion</h3>
						<p class="fragment">Unless you're building a real-time stock trading system, don't do it</p>
					</section>
				</section>
				<section>
					<section><h2>Server-Side Rendering</h2></section>
					<section><h3>What is it?</h3>
						<p class="fragment">"Classic" SPAs fetch only barebone HTML and lots of resources via HTTP, the app is rendered entirely within the browser</p>
						<p class="fragment">Server-Side Rendered apps are pre-rendered on the server and transmitted as acutal, usuable HTML to the brwoser</p>
					</section>
					<section><h3>Promise</h3>
						<p class="fragment">Instead of downloading multiple megabytes of resources prior to bootstrapping, the first assets to be transferred are already usable HTML</p>
						<p class="fragment">Faster load times, less flicker</p>
					</section>
					<section><h3>Pitfalls</h3>
						<p class="fragment">We need to build an SPA that can be rendered in the backend and then be hydrated in the browser</p>
						<p class="fragment">There are SPA frameworks promising to deliver server-side rendering with a smooth developer experience (hi Nuxt &#128075;), but offer a questionable experience in other aspects (our test API is still in development and should not be used for production &#128169;)</p>
					</section>
					<section><h3>Conclusion</h3>
						<p class="fragment">YAGNI</p>
					</section>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
